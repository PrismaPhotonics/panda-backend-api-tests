# ×“×•×’×××•×ª ×§×•×“ - Frontend Validation
## Client-Side Validation Examples

**××˜×¨×”:** ×œ×”×¨××•×ª ×œ× ×•×’×” ××™×š ×•×•×•×œ×™×“×¦×™×” ×‘×§×œ×™×™× ×˜ ×××•×¨×” ×œ×”×™×¨××•×ª

---

## ğŸ¯ ×¢×™×§×¨×•×Ÿ Defense in Depth

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  User Input (Frontend)                  â”‚
â”‚  â†“                                       â”‚
â”‚  âœ… Validation Layer 1: UI Constraints  â”‚  â† ××•× ×¢ ×”×–× ×” ×©×’×•×™×”
â”‚  â†“                                       â”‚
â”‚  âœ… Validation Layer 2: Form Validation â”‚  â† ×‘×“×™×§×” ×œ×¤× ×™ ×©×œ×™×—×”
â”‚  â†“                                       â”‚
â”‚  ğŸŒ HTTP Request â†’ Backend              â”‚
â”‚  â†“                                       â”‚
â”‚  âœ… Validation Layer 3: Server-Side     â”‚  â† ×”×’× ×” ××—×¨×•× ×”
â”‚  â†“                                       â”‚
â”‚  ğŸ’¾ Database / Processing               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**×œ××” ×¦×¨×™×š ××ª ×›×œ ×”×©×›×‘×•×ª?**
- Layer 1+2: ×—×•×•×™×™×ª ××©×ª××© + ×× ×™×¢×” ××•×§×“××ª
- Layer 3: ××‘×˜×—×” + ×”×’× ×” ××¤× ×™ API calls ×™×©×™×¨×•×ª

---

## 1ï¸âƒ£ displayInfo.height - ×“×•×’×××•×ª

### âœ… ×’×™×©×” 1: HTML5 Native Validation

```html
<label for="height">Display Height (pixels):</label>
<input 
  type="number" 
  id="height" 
  name="height"
  min="1"           <!-- âœ… ×œ× ×××¤×©×¨ ×¢×¨×›×™× ×©×œ×™×œ×™×™× -->
  max="5000"        <!-- âœ… ×”×’×‘×œ×” ×¢×œ×™×•× ×” ×¡×‘×™×¨×” -->
  required          <!-- âœ… ×©×“×” ×—×•×‘×” -->
  value="1000"
/>
```

**×™×ª×¨×•× ×•×ª:**
- âœ… ×¤×©×•×˜ ×××•×“
- âœ… ×¢×•×‘×“ ××™×“ ×œ×œ× JavaScript
- âœ… UI native ×©×œ ×”×“×¤×“×¤×Ÿ

**×—×¡×¨×•× ×•×ª:**
- âš ï¸ ××©×ª××© ×¢×“×™×™×Ÿ ×™×›×•×œ ×œ×”×§×œ×™×“ `-100` ×™×“× ×™×ª
- âš ï¸ ×¦×¨×™×š JavaScript validation × ×•×¡×£

---

### âœ… ×’×™×©×” 2: React + Validation Library (Formik + Yup)

```jsx
import { Formik, Form, Field } from 'formik';
import * as Yup from 'yup';

// âœ… Schema ××•×’×“×¨ ×‘××¤×•×¨×©
const ConfigSchema = Yup.object().shape({
  displayInfo: Yup.object().shape({
    height: Yup.number()
      .required('Height is required')
      .positive('Height must be positive')  // âœ… ×¨×§ ×¢×¨×›×™× ×—×™×•×‘×™×™×
      .integer('Height must be an integer')
      .min(1, 'Height must be at least 1')
      .max(5000, 'Height cannot exceed 5000')
  })
});

function ConfigForm() {
  return (
    <Formik
      initialValues={{ displayInfo: { height: 1000 } }}
      validationSchema={ConfigSchema}
      onSubmit={(values) => {
        // âœ… ×¨×§ × ×ª×•× ×™× ×ª×§×™× ×™× ××’×™×¢×™× ×œ×›××Ÿ
        sendToBackend(values);
      }}
    >
      {({ errors, touched }) => (
        <Form>
          <Field name="displayInfo.height" type="number" />
          
          {/* âœ… ×”×¦×’×ª ×©×’×™××” ×œ××©×ª××© */}
          {errors.displayInfo?.height && touched.displayInfo?.height && (
            <div className="error">{errors.displayInfo.height}</div>
          )}
          
          <button type="submit">Configure</button>
        </Form>
      )}
    </Formik>
  );
}
```

**×™×ª×¨×•× ×•×ª:**
- âœ… ×•×•×•×œ×™×“×¦×™×” ××§×™×¤×”
- âœ… ×”×•×“×¢×•×ª ×©×’×™××” ×‘×¨×•×¨×•×ª
- âœ… ×©×’×™××” ××•×¦×’×ª ×œ××©×ª××© ×œ×¤× ×™ ×©×œ×™×—×”

---

### âœ… ×’×™×©×” 3: React Hook Form + Zod

```typescript
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

// âœ… Schema ×˜×™×™×¤-×‘×˜×•×—
const configSchema = z.object({
  displayInfo: z.object({
    height: z.number()
      .positive("Height must be positive")
      .int("Height must be an integer")
      .min(1, "Height must be at least 1")
      .max(5000, "Height cannot exceed 5000")
  })
});

type ConfigFormData = z.infer<typeof configSchema>;

function ConfigForm() {
  const { register, handleSubmit, formState: { errors } } = useForm<ConfigFormData>({
    resolver: zodResolver(configSchema)
  });

  const onSubmit = (data: ConfigFormData) => {
    // âœ… TypeScript + Runtime validation
    sendToBackend(data);
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <input 
        type="number" 
        {...register("displayInfo.height", { valueAsNumber: true })}
      />
      
      {/* âœ… ×”×¦×’×ª ×©×’×™××” */}
      {errors.displayInfo?.height && (
        <span className="error">{errors.displayInfo.height.message}</span>
      )}
      
      <button type="submit">Configure</button>
    </form>
  );
}
```

---

## 2ï¸âƒ£ nfftSelection - ×“×•×’×××•×ª

### âœ… ×’×™×©×” ××•××œ×¦×ª: Dropdown (Select)

```jsx
import { Field } from 'formik';

// âœ… ×¢×¨×›×™× ×ª×§×™× ×™× ×‘×œ×‘×“
const VALID_NFFT_VALUES = [256, 512, 1024, 2048];

function NFFFTSelector() {
  return (
    <div>
      <label htmlFor="nfftSelection">NFFT Selection:</label>
      <Field as="select" name="nfftSelection" id="nfftSelection">
        {VALID_NFFT_VALUES.map(value => (
          <option key={value} value={value}>
            {value}
          </option>
        ))}
      </Field>
    </div>
  );
}
```

**×œ××” Dropdown ×”×›×™ ×˜×•×‘?**
- âœ… **××™ ××¤×©×¨** ×œ×”×–×™×Ÿ ×¢×¨×›×™× ×©×’×•×™×™×
- âœ… ××©×ª××© ×¨×•××” ×¨×§ ××•×¤×¦×™×•×ª ×ª×§×™× ×•×ª
- âœ… ×¤×©×•×˜ ×œ×™×™×©×•×

---

### âš ï¸ ×’×™×©×” ×œ× ××•××œ×¦×ª: Input ×—×•×¤×©×™

```jsx
// âŒ ×¨×¢ - ×××¤×©×¨ ×¢×¨×›×™× ×œ× ×ª×§×™× ×™×
<input type="number" name="nfftSelection" />

// âš ï¸ ×× ×—×™×™×‘×™× input ×—×•×¤×©×™, ×¦×¨×™×š validation ××—××™×¨:
const nfftSchema = Yup.number()
  .required('NFFT is required')
  .oneOf([256, 512, 1024, 2048], 'NFFT must be 256, 512, 1024, or 2048')
  .test('is-power-of-2', 'NFFT must be power of 2', value => {
    return value && (value & (value - 1)) === 0;  // âœ… ×‘×“×™×§×ª power-of-2
  })
  .max(2048, 'NFFT cannot exceed 2048');
```

---

### âœ… ×’×™×©×” ×—×œ×•×¤×™×ª: Radio Buttons

```jsx
const VALID_NFFT_VALUES = [256, 512, 1024, 2048];

function NFFFTSelector() {
  return (
    <fieldset>
      <legend>NFFT Selection:</legend>
      {VALID_NFFT_VALUES.map(value => (
        <label key={value}>
          <Field 
            type="radio" 
            name="nfftSelection" 
            value={value}
          />
          {value}
        </label>
      ))}
    </fieldset>
  );
}
```

---

## 3ï¸âƒ£ frequencyRange - ×“×•×’×××•×ª (×”×›×™ ××•×¨×›×‘!)

### âœ… ×’×™×©×”: Dynamic Validation ×¢× Metadata

```typescript
import { useEffect, useState } from 'react';
import * as Yup from 'yup';

function FrequencyRangeForm() {
  const [metadata, setMetadata] = useState<any>(null);
  const [nyquistLimit, setNyquistLimit] = useState<number>(0);

  // âœ… ×©×œ×‘ 1: ×§×‘×œ×ª metadata ××”×©×¨×ª
  useEffect(() => {
    async function fetchMetadata() {
      const response = await fetch('/api/metadata/current-dataset');
      const data = await response.json();
      
      setMetadata(data);
      
      // âœ… ×©×œ×‘ 2: ×—×™×©×•×‘ Nyquist
      const prr = data.pulse_repetition_rate;  // ×œ××©×œ: 1000 Hz
      const nyquist = prr / 2;                  // 500 Hz
      setNyquistLimit(nyquist);
    }
    
    fetchMetadata();
  }, []);

  // âœ… ×©×œ×‘ 3: Schema ×“×™× ××™
  const FrequencySchema = Yup.object().shape({
    frequencyRange: Yup.object().shape({
      min: Yup.number()
        .required('Min frequency is required')
        .min(0, 'Min frequency must be >= 0'),
      
      max: Yup.number()
        .required('Max frequency is required')
        .min(Yup.ref('min'), 'Max must be >= Min')
        .max(
          nyquistLimit,  // âœ… ×”×’×‘×œ×” ×“×™× ××™×ª!
          `Max frequency cannot exceed Nyquist limit (${nyquistLimit} Hz for this dataset)`
        )
    })
  });

  if (!metadata) {
    return <div>Loading dataset metadata...</div>;
  }

  return (
    <Formik
      initialValues={{ frequencyRange: { min: 0, max: 0 } }}
      validationSchema={FrequencySchema}
      onSubmit={sendToBackend}
    >
      {({ errors, touched, values }) => (
        <Form>
          <div>
            <label>Min Frequency (Hz):</label>
            <Field name="frequencyRange.min" type="number" />
            {errors.frequencyRange?.min && touched.frequencyRange?.min && (
              <span className="error">{errors.frequencyRange.min}</span>
            )}
          </div>

          <div>
            <label>Max Frequency (Hz):</label>
            <Field name="frequencyRange.max" type="number" />
            {errors.frequencyRange?.max && touched.frequencyRange?.max && (
              <span className="error">{errors.frequencyRange.max}</span>
            )}
            
            {/* âœ… ×”×¦×’×ª ××™×“×¢ ×œ××©×ª××© */}
            <small>
              Nyquist limit for this dataset: {nyquistLimit} Hz 
              (PRR: {metadata.pulse_repetition_rate} Hz)
            </small>
          </div>

          <button type="submit">Configure</button>
        </Form>
      )}
    </Formik>
  );
}
```

---

### âœ… ×’×™×©×” ×—×œ×•×¤×™×ª: Slider ×¢× Nyquist Limit

```tsx
import Slider from 'rc-slider';
import 'rc-slider/assets/index.css';

function FrequencySlider({ nyquistLimit }: { nyquistLimit: number }) {
  const [range, setRange] = useState<[number, number]>([0, 250]);

  return (
    <div>
      <label>Frequency Range (Hz):</label>
      
      {/* âœ… Slider ××•×’×‘×œ ××•×˜×•××˜×™×ª */}
      <Slider
        range
        min={0}
        max={nyquistLimit}  // âœ… ×”×’×‘×œ×” ×“×™× ××™×ª
        value={range}
        onChange={setRange}
      />
      
      <div>
        Selected: {range[0]} Hz - {range[1]} Hz
      </div>
      
      <div className="info">
        Maximum allowed: {nyquistLimit} Hz (Nyquist limit for this dataset)
      </div>
    </div>
  );
}
```

**×™×ª×¨×•×Ÿ Slider:**
- âœ… **××™ ××¤×©×¨** ×œ×¢×‘×•×¨ ××ª ×”×’×‘×•×œ
- âœ… UI intuitive
- âœ… ××™×Ÿ ×¦×•×¨×š ×‘validation × ×•×¡×£

---

## 4ï¸âƒ£ channels - ×“×•×’×××•×ª

### âœ… ×’×™×©×”: Real-time Validation

```typescript
import { useFormikContext } from 'formik';

function ChannelRangeSelector() {
  const { values, setFieldError, errors } = useFormikContext<any>();
  
  // âœ… ×—×™×©×•×‘ ×›××•×ª ×¢×¨×•×¦×™× ×‘×–××Ÿ ×××ª
  useEffect(() => {
    const min = values.channels?.min || 0;
    const max = values.channels?.max || 0;
    const count = max - min + 1;
    
    if (count > 2500) {
      setFieldError(
        'channels.max', 
        `Channel count (${count}) exceeds maximum (2500)`
      );
    }
  }, [values.channels?.min, values.channels?.max]);

  return (
    <div>
      <div>
        <label>Min Channel:</label>
        <Field name="channels.min" type="number" min="1" />
      </div>
      
      <div>
        <label>Max Channel:</label>
        <Field name="channels.max" type="number" min="1" />
      </div>
      
      {/* âœ… ×”×¦×’×ª ×›××•×ª ×¢×¨×•×¦×™× */}
      <div className="info">
        Total channels: {values.channels.max - values.channels.min + 1} / 2500
      </div>
      
      {/* âœ… ×”×¦×’×ª ×©×’×™××” ×× ×¢×•×‘×¨ ××ª ×”×’×‘×•×œ */}
      {errors.channels?.max && (
        <div className="error">{errors.channels.max}</div>
      )}
    </div>
  );
}
```

---

### âœ… ×’×™×©×” ×—×œ×•×¤×™×ª: Range Slider ×¢× Limit

```tsx
import Slider from 'rc-slider';

const MAX_CHANNELS = 2500;

function ChannelRangeSlider() {
  const [range, setRange] = useState<[number, number]>([1, 50]);
  
  const handleChange = (newRange: [number, number]) => {
    const [min, max] = newRange;
    const count = max - min + 1;
    
    // âœ… ×‘×“×™×§×” ×‘×–××Ÿ ×××ª
    if (count <= MAX_CHANNELS) {
      setRange(newRange);
    } else {
      // âš ï¸ ××–×”×¨×” ×œ××©×ª××©
      alert(`Cannot select more than ${MAX_CHANNELS} channels`);
    }
  };

  const channelCount = range[1] - range[0] + 1;

  return (
    <div>
      <label>Channel Range:</label>
      
      <Slider
        range
        min={1}
        max={10000}  // ×›×œ ×”×¢×¨×•×¦×™× ×”××¤×©×¨×™×™×
        value={range}
        onChange={handleChange}
      />
      
      <div>
        Selected: Channel {range[0]} - {range[1]}
      </div>
      
      <div className={channelCount > MAX_CHANNELS ? 'error' : 'info'}>
        Total: {channelCount} / {MAX_CHANNELS}
        {channelCount > MAX_CHANNELS && ' âš ï¸ Exceeds maximum!'}
      </div>
    </div>
  );
}
```

---

## ğŸ”„ ×•×•×•×œ×™×“×¦×™×” ××œ××” - ×“×•×’××” ××©×•×œ×‘×ª

```typescript
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useEffect, useState } from 'react';

// âœ… Schema ××œ×
const createConfigSchema = (nyquistLimit: number) => z.object({
  displayInfo: z.object({
    height: z.number()
      .positive("Height must be positive")
      .min(1, "Height must be at least 1")
      .max(5000, "Height cannot exceed 5000")
  }),
  
  nfftSelection: z.number()
    .refine(
      val => [256, 512, 1024, 2048].includes(val),
      "NFFT must be 256, 512, 1024, or 2048"
    ),
  
  frequencyRange: z.object({
    min: z.number().min(0),
    max: z.number().max(nyquistLimit, 
      `Cannot exceed Nyquist limit (${nyquistLimit} Hz)`
    )
  }).refine(
    data => data.max >= data.min,
    "Max must be >= Min"
  ),
  
  channels: z.object({
    min: z.number().min(1),
    max: z.number().min(1)
  }).refine(
    data => (data.max - data.min + 1) <= 2500,
    "Channel count cannot exceed 2500"
  )
});

function CompleteConfigForm() {
  const [nyquistLimit, setNyquistLimit] = useState(500);
  
  // ×§×‘×œ×ª metadata
  useEffect(() => {
    fetchDatasetMetadata().then(metadata => {
      const prr = metadata.pulse_repetition_rate;
      setNyquistLimit(prr / 2);
    });
  }, []);
  
  const { register, handleSubmit, formState: { errors } } = useForm({
    resolver: zodResolver(createConfigSchema(nyquistLimit))
  });
  
  const onSubmit = async (data: any) => {
    try {
      // âœ… × ×ª×•× ×™× ×ª×§×™× ×™× - ×©×œ×™×—×” ×œ×©×¨×ª
      const response = await fetch('/focus-server/configure', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
      
      if (!response.ok) {
        // âš ï¸ ×©×¨×ª ×“×—×” (Defense in Depth ×¢×•×‘×“!)
        const error = await response.json();
        alert(`Server error: ${error.message}`);
      } else {
        alert('Configuration successful!');
      }
    } catch (error) {
      console.error('Failed to send configuration', error);
    }
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* Form fields... */}
      <button type="submit">Configure</button>
    </form>
  );
}
```

---

## ğŸ“Š ×¡×™×›×•× - ××” ×”×§×œ×™×™× ×˜ ×¦×¨×™×š ×œ×‘×“×•×§?

| ×¤×¨××˜×¨ | ×‘×“×™×§×” | ×“×•×’××ª ×§×•×“ |
|-------|-------|-----------|
| **height** | `> 0, <= 5000` | `z.number().positive().max(5000)` |
| **nfftSelection** | `âˆˆ [256,512,1024,2048]` | `z.number().refine(val => [256,512,1024,2048].includes(val))` |
| **frequencyRange** | `max <= Nyquist` | `z.number().max(nyquistLimit)` |
| **channels** | `count <= 2500` | `refine(data => (data.max-data.min+1) <= 2500)` |

---

## ğŸ’¡ Best Practices ×œ× ×•×’×”

### âœ… ××•××œ×¥:
1. **×”×©×ª××©×• ×‘-Validation Library** (Yup, Zod, React Hook Form)
2. **UI Constraints** (Dropdown ×œ××§×•× ×©××¤×©×¨)
3. **Real-time Feedback** (×©×’×™××•×ª ×‘×–××Ÿ ×××ª)
4. **Dynamic Validation** (Nyquist ×ª×œ×•×™ ×‘-metadata)

### âš ï¸ ×œ×”×™×× ×¢:
1. Input ×—×•×¤×©×™ ×œ×œ× validation
2. Validation ×¨×§ ×œ×¤× ×™ ×©×œ×™×—×” (×××•×—×¨ ××“×™!)
3. ×”×•×“×¢×•×ª ×©×’×™××” ×œ× ×‘×¨×•×¨×•×ª
4. Hard-coded limits (×‘××§×•× dynamic)

---

## ğŸ” ××™×š ×œ×‘×“×•×§ ××ª ×”×§×•×“ ×”×§×™×™× ×©×œ × ×•×’×”?

### ×©××œ×•×ª ×œ×©××•×œ:
```
â–¡ ×™×© validation library? (Yup, Zod, ×•×›×•')
â–¡ ××™×¤×” ×”-validation ××•×’×“×¨? (×§×•×‘×¥ ×¡×¤×¦×™×¤×™?)
â–¡ ×™×© validation schemas?
â–¡ ×™×© UI constraints? (min/max, dropdown)
â–¡ ×™×© ×‘×“×™×§×•×ª ×‘×–××Ÿ ×××ª?
â–¡ ××™×š ××˜×¤×œ×™× ×‘-metadata? (PRR, Nyquist)
```

### ×“×‘×¨×™× ×œ×—×¤×© ×‘×§×•×“:
```typescript
// âœ… ×˜×•×‘ - ×™×© validation schema
const schema = Yup.object({...});

// âœ… ×˜×•×‘ - ×™×© validation ×œ×¤× ×™ ×©×œ×™×—×”
const { errors } = useForm({ resolver: zodResolver(schema) });

// âš ï¸ ×¨×¢ - input ×—×•×¤×©×™ ×œ×œ× validation
<input type="number" />

// âš ï¸ ×¨×¢ - hard-coded limits
if (value > 500) { ... }  // âŒ Nyquist ×¦×¨×™×š ×œ×”×™×•×ª ×“×™× ××™!
```

---

**×œ×”×“×¤×™×¡ ×•×œ×”×‘×™× ×œ×¤×’×™×©×” âœ“**


"""
PZ RPC Integration Example
==========================

Demonstrates how to use PZ's RPC-over-RabbitMQ pattern (inspired by bit microservice)
to integrate with Focus Server and Baby Analyzer.

This example shows:
1. How PZ microservices use RPC Server/Client pattern
2. How to send commands using Producer pattern
3. How to integrate this with our testing framework

Author: QA Automation Architect
Date: 2025-10-08
"""

import sys
import logging
from pathlib import Path
from typing import Dict, Optional

# Add project root to path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from config.config_manager import ConfigManager
from src.apis.baby_analyzer_mq_client import BabyAnalyzerMQClient
from src.models.baby_analyzer_models import ColorMap

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s'
)
logger = logging.getLogger(__name__)


# =============================================================================
# EXAMPLE 1: RPC Server/Client Pattern (inspired by data_manager_service.py)
# =============================================================================

class MockFocusServerRPCServer:
    """
    Mock RPC Server for Focus Server.
    
    In real PZ microservices, this would inherit from rpc.RpcServer.
    This demonstrates the pattern without requiring pz_core_libs.
    """
    
    def __init__(self, queue_name: str = 'FocusServerRPC'):
        self.queue_name = queue_name
        logger.info(f"Mock RPC Server initialized for queue: {queue_name}")
    
    def handle_config_request(self, task_id: str, config: Dict) -> Dict:
        """
        Mock RPC method that would handle configuration requests.
        
        In real implementation, decorated with @rpc.method()
        """
        logger.info(f"Received config request for task: {task_id}")
        return {
            'status': 'success',
            'task_id': task_id,
            'message': 'Configuration applied'
        }
    
    def get_waterfall_data(self, task_id: str, row_count: int) -> Dict:
        """
        Mock RPC method for waterfall data retrieval.
        
        In real implementation, decorated with @rpc.method()
        """
        logger.info(f"Received waterfall request: task={task_id}, rows={row_count}")
        return {
            'task_id': task_id,
            'rows_returned': row_count,
            'data': []
        }


class MockFocusServerRPCClient:
    """
    Mock RPC Client for Focus Server.
    
    In real PZ microservices, this would inherit from rpc.RpcClient.
    Demonstrates how client calls remote methods.
    """
    
    def __init__(self, broker_uri: Optional[str] = None):
        self.broker_uri = broker_uri or 'localhost'
        logger.info(f"Mock RPC Client initialized, broker: {self.broker_uri}")
    
    def handle_config_request(self, task_id: str, config: Dict) -> Dict:
        """
        Client interface for config request.
        
        In real implementation:
        - Decorated with @rpc.interface
        - Implementation auto-generated by decorator
        - Sends RPC call over RabbitMQ
        - Waits for response
        """
        logger.info(f"Calling remote RPC: handle_config_request({task_id})")
        # In real implementation, this would:
        # 1. Serialize the call
        # 2. Send to RabbitMQ queue
        # 3. Wait for response
        # 4. Deserialize and return
        return {'status': 'mock_response', 'task_id': task_id}
    
    def get_waterfall_data(self, task_id: str, row_count: int) -> Dict:
        """Client interface for waterfall data."""
        logger.info(f"Calling remote RPC: get_waterfall_data({task_id}, {row_count})")
        return {'status': 'mock_response', 'task_id': task_id}


# =============================================================================
# EXAMPLE 2: Producer Pattern (inspired by TelegrafRabbitProducer)
# =============================================================================

class MockMetricsProducer:
    """
    Mock Producer for sending metrics/commands.
    
    In real PZ, this would use pz_core_libs.msgbus.producer.Producer
    """
    
    def __init__(self):
        logger.info("Mock Metrics Producer initialized")
    
    def publish(self, message: Dict):
        """
        Publish message to RabbitMQ.
        
        In real implementation:
        - Serializes message
        - Sends to RabbitMQ exchange/queue
        - Fire-and-forget (no response expected)
        """
        logger.info(f"Publishing message: {message}")
        return True


# =============================================================================
# EXAMPLE 3: Integration with Baby Analyzer MQ Client
# =============================================================================

def demonstrate_baby_analyzer_commands(env: str = "staging"):
    """
    Demonstrates sending commands to Baby Analyzer using our MQ Client.
    
    This uses the real BabyAnalyzerMQClient we created.
    """
    logger.info("=" * 70)
    logger.info("DEMO: Baby Analyzer Commands via RabbitMQ")
    logger.info("=" * 70)
    
    try:
        # Load config
        config = ConfigManager(env)
        rabbitmq_config = config.get("rabbitmq", {})
        
        # Create client
        with BabyAnalyzerMQClient(
            host=rabbitmq_config.get("host", "localhost"),
            port=rabbitmq_config.get("port", 5672),
            username=rabbitmq_config.get("username", "guest"),
            password=rabbitmq_config.get("password", "guest"),
            virtual_host=rabbitmq_config.get("vhost", "/")
        ) as client:
            
            logger.info("[+] Connected to RabbitMQ")
            
            # Send keepalive (like bit microservice sends test results)
            logger.info("\n[>] Sending Keepalive command...")
            client.send_keepalive(source="pz_rpc_example")
            logger.info("[+] Keepalive sent")
            
            # Send ROI change
            logger.info("\n[>] Sending ROI change command...")
            client.send_roi_change(start=100, end=200)
            logger.info("[+] ROI change sent")
            
            # Send colormap change
            logger.info("\n[>] Sending colormap change...")
            client.send_colormap_change(ColorMap.JET)
            logger.info("[+] Colormap change sent")
            
            # Send caxis adjustment
            logger.info("\n[>] Sending caxis adjustment...")
            client.send_caxis_adjust(min_value=-15.0, max_value=15.0)
            logger.info("[+] Caxis adjustment sent")
            
            logger.info("\n[+] All commands sent successfully!")
            return True
            
    except Exception as e:
        logger.error(f"[X] Error: {e}")
        return False


def demonstrate_rpc_pattern():
    """
    Demonstrates the RPC Server/Client pattern used in PZ.
    """
    logger.info("=" * 70)
    logger.info("DEMO: RPC Server/Client Pattern (like data_manager)")
    logger.info("=" * 70)
    
    # Server side (would run in microservice container)
    server = MockFocusServerRPCServer()
    
    # Client side (would run in our tests)
    client = MockFocusServerRPCClient()
    
    # Make RPC calls
    logger.info("\n[>] Client calling server methods...")
    
    result1 = client.handle_config_request(
        task_id="test_task_001",
        config={"sensorRange": {"start": 0, "end": 1000}}
    )
    logger.info(f"[+] Response: {result1}")
    
    result2 = client.get_waterfall_data(
        task_id="test_task_001",
        row_count=100
    )
    logger.info(f"[+] Response: {result2}")


def demonstrate_producer_pattern():
    """
    Demonstrates the Producer pattern for fire-and-forget messages.
    """
    logger.info("=" * 70)
    logger.info("DEMO: Producer Pattern (like TelegrafRabbitProducer)")
    logger.info("=" * 70)
    
    producer = MockMetricsProducer()
    
    # Send metrics/commands
    logger.info("\n[>] Sending metrics...")
    
    producer.publish({
        'measurement': 'bit-test',
        'tags': {
            'component': 'focus_server',
            'test': 'config_validation'
        },
        'fields': {
            'passed': 1
        }
    })
    
    producer.publish({
        'measurement': 'bit-test',
        'tags': {
            'component': 'baby_analyzer',
            'test': 'roi_adjustment'
        },
        'fields': {
            'passed': 1
        }
    })
    
    logger.info("[+] Metrics sent")


# =============================================================================
# KEY PATTERNS FROM PZ MICROSERVICES
# =============================================================================

def print_patterns_summary():
    """Print summary of key patterns learned from bit microservice."""
    logger.info("="*70)
    logger.info("KEY PATTERNS FROM PZ MICROSERVICES (bit, etc.)")
    logger.info("="*70)
    
    logger.info("\n[1] RPC SERVER/CLIENT PATTERN")
    logger.info("-" * 70)
    logger.info("Used by: data_manager, data_collection_server, focus_server")
    logger.info("\nServer Side:")
    logger.info("  class MyService(rpc.RpcServer):")
    logger.info("      @rpc.method()")
    logger.info("      def my_method(self, param):")
    logger.info("          return result")
    logger.info("\nClient Side:")
    logger.info("  class MyClient(rpc.RpcClient):")
    logger.info("      @rpc.interface")
    logger.info("      def my_method(self, param):")
    logger.info("          pass  # Auto-implemented!")
    
    logger.info("\n[2] PRODUCER PATTERN")
    logger.info("-" * 70)
    logger.info("Used by: bit (TelegrafRabbitProducer)")
    logger.info("\nFire-and-forget messages:")
    logger.info("  producer = RabbitProducer()")
    logger.info("  message = InfluxLineMetricMessage(metrics)")
    logger.info("  producer.publish(message)")
    
    logger.info("\n[3] COMMAND PATTERN")
    logger.info("-" * 70)
    logger.info("Used by: baby_analyzer")
    logger.info("\nSend commands via dedicated channels:")
    logger.info("  - ROI changes")
    logger.info("  - Colormap changes")
    logger.info("  - Caxis adjustments")
    logger.info("  - Keepalive signals")
    
    logger.info("\n[4] THREADING & QUEUES")
    logger.info("-" * 70)
    logger.info("Used by: data_manager workers")
    logger.info("\nBackground processing:")
    logger.info("  class Worker(threading.Thread):")
    logger.info("      def __init__(self):")
    logger.info("          self.job_queue = queue.SimpleQueue()")
    logger.info("      def run(self):")
    logger.info("          while True:")
    logger.info("              job = self.job_queue.get()")
    logger.info("              # Process job...")
    
    logger.info("\n" + "="*70)
    logger.info("HOW TO USE IN YOUR TESTS")
    logger.info("="*70)
    logger.info("  [+] For Request/Response: Use REST API (focus_server_api.py)")
    logger.info("  [+] For Commands: Use RabbitMQ (baby_analyzer_mq_client.py)")
    logger.info("  [+] For Monitoring: Use RabbitMQ Consumer + REST polling")
    logger.info("  [+] For Metrics: Send to Telegraf (like bit microservice)")


def main():
    """Main entry point."""
    import argparse
    
    parser = argparse.ArgumentParser(description="PZ RPC Integration Examples")
    parser.add_argument("--env", default="staging", help="Environment name")
    parser.add_argument("--demo", choices=["rpc", "producer", "baby_analyzer", "all"],
                       default="all", help="Which demo to run")
    
    args = parser.parse_args()
    
    try:
        if args.demo in ["rpc", "all"]:
            demonstrate_rpc_pattern()
            print()
        
        if args.demo in ["producer", "all"]:
            demonstrate_producer_pattern()
            print()
        
        if args.demo in ["baby_analyzer", "all"]:
            demonstrate_baby_analyzer_commands(args.env)
            print()
        
        print_patterns_summary()
        
        logger.info("=" * 70)
        logger.info("[+] All demos completed successfully!")
        logger.info("=" * 70)
        
    except Exception as e:
        logger.error(f"[X] Error running demos: {e}", exc_info=True)
        return 1
    
    return 0


if __name__ == "__main__":
    sys.exit(main())


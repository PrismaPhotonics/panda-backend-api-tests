name: Smoke Tests

on:
  push:
    branches: [ main, develop, master, "chore/add-roy-tests" ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      require_server:
        description: "Fail if Focus server is unreachable"
        default: "true"
        type: choice
        options: [ "true", "false" ]

env:
  PYTHON_VERSION: '3.13'

jobs:
  smoke:
    # IMPORTANT: Use self-hosted Windows runner for production environment access
    # Cloud runners cannot access internal network (10.10.10.100)
    runs-on: [self-hosted, windows, "panda_automation"]
    permissions:
      checks: write
      pull-requests: write
      contents: read
    timeout-minutes: 15

    env:
      FOCUS_SERVER_HOST: ${{ secrets.FOCUS_SERVER_HOST || '10.10.10.100' }}
      FOCUS_SERVER_PORT: ${{ secrets.FOCUS_SERVER_PORT || '' }}
      FOCUS_API_PREFIX: ${{ secrets.FOCUS_API_PREFIX || '/focus-server' }}
      VERIFY_SSL: ${{ secrets.VERIFY_SSL || 'false' }}
      REQUIRE_SERVER: ${{ inputs.require_server || secrets.REQUIRE_SERVER || 'true' }}
      ENVIRONMENT: ${{ secrets.ENVIRONMENT || 'staging' }}
      PYTHONDONTWRITEBYTECODE: 1
      PYTHONUNBUFFERED: 1
      PYTHONPATH: ${{ github.workspace }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        shell: powershell
        run: |
          $ErrorActionPreference = 'Continue'
          # Use existing Python installation instead of setup-python to avoid registry permission issues
          $pythonVersion = py --version 2>&1 | Select-String -Pattern "Python (\d+\.\d+)" | ForEach-Object { $_.Matches[0].Groups[1].Value }
          if ($pythonVersion) {
            Write-Host "Found Python $pythonVersion via py launcher"
            # Get Python path and Scripts directory
            $pythonPath = py -c "import sys; print(sys.executable)" 2>&1
            if ($pythonPath -and -not ($pythonPath -match "Error|Exception")) {
              $pythonDir = Split-Path $pythonPath
              $scriptsDir = Join-Path $pythonDir "Scripts"
              
              # Use GITHUB_PATH to persist PATH across steps
              if ($env:GITHUB_PATH) {
                echo "$pythonDir" | Out-File -FilePath $env:GITHUB_PATH -Append -Encoding utf8
                echo "$scriptsDir" | Out-File -FilePath $env:GITHUB_PATH -Append -Encoding utf8
              }
              
              Write-Host "Python path: $pythonPath"
              Write-Host "Scripts path: $scriptsDir"
            } else {
              Write-Host "Warning: Could not get Python path, but py launcher works"
            }
          } else {
            Write-Host "Python not found via py launcher, trying python directly..."
            # Try to find python in common locations
            $pythonPaths = @(
              "C:\Python*",
              "C:\Program Files\Python*",
              "C:\Users\$env:USERNAME\AppData\Local\Programs\Python\Python*"
            )
            foreach ($pathPattern in $pythonPaths) {
              $foundPython = Get-ChildItem -Path $pathPattern -Filter "python.exe" -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($foundPython) {
                $pythonDir = Split-Path $foundPython.FullName
                $scriptsDir = Join-Path $pythonDir "Scripts"
                
                # Use GITHUB_PATH to persist PATH across steps
                if ($env:GITHUB_PATH) {
                  echo "$pythonDir" | Out-File -FilePath $env:GITHUB_PATH -Append -Encoding utf8
                  echo "$scriptsDir" | Out-File -FilePath $env:GITHUB_PATH -Append -Encoding utf8
                }
                
                Write-Host "Found Python at: $($foundPython.FullName)"
                break
              }
            }
          }
          # Verify Python is accessible (use py launcher which is always in PATH)
          Write-Host "Verifying Python access:"
          py --version
          $pipResult = py -m pip --version 2>&1
          if ($LASTEXITCODE -ne 0) {
            Write-Host "Warning: pip not accessible via py -m pip, but continuing..."
            Write-Host "pip output: $pipResult"
          } else {
            Write-Host "pip is accessible"
          }

      - name: Install deps
        shell: powershell
        run: |
          # Use py launcher which is always in PATH, or python if PATH was set correctly
          py -m ensurepip --upgrade
          py -m pip install --upgrade pip
          if (Test-Path requirements.txt) {
            py -m pip install -r requirements.txt
          }
          py -m pip install pytest pytest-cov requests

      - name: Install project in editable mode
        shell: powershell
        run: |
          Write-Host "Installing project in editable mode..."
          py -m pip install -e .
          if ($LASTEXITCODE -ne 0) {
            Write-Host "::warning::Failed to install project in editable mode, continuing anyway..."
          } else {
            Write-Host "Project installed successfully"
          }

      - name: Verify Python and pytest installation
        shell: powershell
        run: |
          where.exe py
          py --version
          # Verify pytest is installed (check if it can be imported, not run)
          # This avoids loading conftest.py which requires external module
          py -c "import pytest; print(f'pytest {pytest.__version__}')"

      - name: Verify infrastructure access
        shell: powershell
        run: |
          Write-Host "========================================"
          Write-Host "Verifying Infrastructure Access"
          Write-Host "========================================"
          Write-Host ""
          
          # Check environment variables
          Write-Host "Environment Variables:"
          Write-Host "  USERPROFILE: $env:USERPROFILE"
          Write-Host "  USERNAME: $env:USERNAME"
          Write-Host "  COMPUTERNAME: $env:COMPUTERNAME"
          Write-Host ""
          
          # Check SSH key in multiple possible locations
          Write-Host "Checking SSH key..."
          $sshKeyFound = $false
          $sshKeyPaths = @()
          
          # Try USERPROFILE first
          if ($env:USERPROFILE) {
            $sshKeyPaths += "$env:USERPROFILE\.ssh\panda_staging_key"
          }
          
          # Try USERNAME-based path
          if ($env:USERNAME) {
            $sshKeyPaths += "C:\Users\$env:USERNAME\.ssh\panda_staging_key"
          }
          
          # Try common service account paths
          $sshKeyPaths += "C:\Windows\system32\config\systemprofile\.ssh\panda_staging_key"
          $sshKeyPaths += "C:\actions-runner\.ssh\panda_staging_key"
          
          foreach ($path in $sshKeyPaths) {
            Write-Host "  Checking: $path"
            if (Test-Path $path) {
              $keyInfo = Get-Item $path
              Write-Host "  [OK] SSH key found at: $path (Size: $($keyInfo.Length) bytes)"
              $sshKeyFound = $true
              break
            }
          }
          
          if (-not $sshKeyFound) {
            Write-Host "  [ERROR] SSH key NOT found in any of the checked locations!"
            Write-Host ""
            Write-Host "  Required: panda_staging_key must be placed in one of:"
            if ($env:USERNAME) {
              Write-Host "    - C:\Users\$env:USERNAME\.ssh\panda_staging_key"
            }
            Write-Host "    - C:\actions-runner\.ssh\panda_staging_key"
            Write-Host ""
            Write-Host "  Health check will FAIL without SSH key!"
            Write-Host "  SSH is required for: Kubernetes, RabbitMQ checks"
          }
          Write-Host ""
          
          # Check kubeconfig
          $kubeConfigPath = "$env:USERPROFILE\.kube\config-panda"
          $kubeConfigDefault = "$env:USERPROFILE\.kube\config"
          Write-Host "Checking Kubernetes config..."
          Write-Host "  Path: $kubeConfigPath"
          if (Test-Path $kubeConfigPath) {
            Write-Host "  [OK] Kubeconfig found"
          } elseif (Test-Path $kubeConfigDefault) {
            Write-Host "  [OK] Default kubeconfig found"
          } else {
            Write-Host "  [WARN] Kubeconfig NOT found"
            Write-Host "  Health check will use SSH fallback if SSH works"
          }
          Write-Host ""
          
          # Check kubectl
          $kubectl = Get-Command kubectl -ErrorAction SilentlyContinue
          if ($kubectl) {
            Write-Host "  [OK] kubectl found: $($kubectl.Source)"
          } else {
            Write-Host "  [WARN] kubectl not found in PATH"
            Write-Host "  Health check will use SSH fallback if SSH works"
          }
          Write-Host ""
          
          Write-Host "========================================"
          Write-Host ""

      - name: Preflight – check Focus availability
        id: preflight
        shell: powershell
        continue-on-error: true
        run: |
          # Initialize outputs with defaults
          echo "reachable=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          echo "status=000" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          
          # Build base URL
          $BASE = "https://$env:FOCUS_SERVER_HOST$env:FOCUS_API_PREFIX"
          Write-Host "Checking $BASE/channels"
          Write-Host "FOCUS_SERVER_HOST: $env:FOCUS_SERVER_HOST"
          Write-Host "FOCUS_SERVER_PORT: $($env:FOCUS_SERVER_PORT -replace '^$', '(not used - HTTPS default)')"
          Write-Host "REQUIRE_SERVER: $env:REQUIRE_SERVER"
          Write-Host ""
          Write-Host "Network diagnostics:"
          Write-Host "  Hostname: $env:COMPUTERNAME"
          Write-Host "  User: $env:USERNAME"
          Write-Host ""
          Write-Host "Testing HTTP connection with curl.exe:"
          Write-Host "  URL: $BASE/channels"
          
          $code = "000"  # Initialize before try block
          try {
            # Use curl.exe which works reliably with TLS on PowerShell 5.1
            $curlOutput = curl.exe -k -s -w "`n%{http_code}" "$BASE/channels" 2>&1
            if ($LASTEXITCODE -eq 0) {
              # Split output: last line is status code, rest is response
              $lines = $curlOutput -split "`n"
              $code = $lines[-1].Trim()
              $responseBody = ($lines[0..($lines.Length-2)] -join "`n").Trim()
              
              if ($code -match '^\d{3}$' -and [int]$code -ge 200 -and [int]$code -lt 400) {
                Write-Host "  [OK] HTTP request succeeded with HTTP $code"
                Write-Host "  Response: $($responseBody.Substring(0, [Math]::Min(100, $responseBody.Length)))"
                echo "reachable=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
                echo "status=$code" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
                Write-Host "[OK] Focus server is reachable"
              } else {
                echo "reachable=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
                echo "status=$code" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
                Write-Host "[FAIL] Focus server unreachable (HTTP $code)"
              }
            } else {
              throw "curl.exe failed with exit code: $LASTEXITCODE"
            }
          } catch {
            $code = "000"
            echo "reachable=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            echo "status=$code" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            Write-Host "[FAIL] Focus server unreachable (Connection failed)"
            Write-Host "  Error: $($_.Exception.Message)"
            
            if ($env:REQUIRE_SERVER -eq "true") {
              Write-Host "::error::Focus server unreachable. Server must be accessible for smoke tests."
            }
          }
          
          Write-Host ""
          Write-Host "Final HTTP status code: $code"

      - name: Run smoke tests
        id: run-smoke-tests
        shell: powershell
        continue-on-error: true  # Allow workflow to continue so test-reporter can publish results
        env:
          PYTHONPATH: ${{ github.workspace }}
        run: |
          $FOCUS_URL = "$env:FOCUS_SERVER_HOST$env:FOCUS_API_PREFIX"
          Write-Host "FOCUS: https://$FOCUS_URL  VERIFY_SSL=$env:VERIFY_SSL"
          
          # Get reachable status
          $REACHABLE = "${{ steps.preflight.outputs.reachable }}"
          if ([string]::IsNullOrEmpty($REACHABLE)) {
            $REACHABLE = "false"
          }
          Write-Host "Server reachable: $REACHABLE"
          Write-Host "Require server: $env:REQUIRE_SERVER"
          
          if (-not (Test-Path test-results)) {
            New-Item -ItemType Directory -Path test-results | Out-Null
          }
          
          # Fail if server is unreachable and REQUIRE_SERVER=true
          if ($REACHABLE -ne "true" -and $env:REQUIRE_SERVER -eq "true") {
            Write-Host "::error::Server unreachable and REQUIRE_SERVER=true - cannot run smoke tests"
            $xmlContent = '<?xml version="1.0" encoding="UTF-8"?><testsuite name="smoke" tests="0" failures="0" errors="1" skipped="0" time="0"><testcase name="server_unreachable" classname="preflight"><error message="Server unreachable and REQUIRE_SERVER=true" type="ConnectionError">Server unreachable and REQUIRE_SERVER=true</error></testcase></testsuite>'
            $xmlContent | Out-File -FilePath test-results/junit-smoke.xml -Encoding utf8
            exit 1
          }
          
          # Skip tests if server unreachable and REQUIRE_SERVER=false
          if ($REACHABLE -ne "true") {
            Write-Host "[SKIP] Server unreachable - skipping smoke tests"
            $xmlContent = '<?xml version="1.0" encoding="UTF-8"?><testsuite name="smoke" tests="0" failures="0" errors="0" skipped="1" time="0"><testcase name="server_unreachable" classname="preflight"><skipped message="Server unreachable"/></testcase></testsuite>'
            $xmlContent | Out-File -FilePath test-results/junit-smoke.xml -Encoding utf8
            exit 0
          }
          
          # Run smoke tests (excluding UI and stress tests)
          # Note: Health checks will run and verify all infrastructure components
          # IMPORTANT: Use explicit paths to avoid collection errors from ignored directories
          $xmlFile = "test-results/junit-smoke.xml"
          $exitCode = 1  # Default to failure
          
          try {
            py -m pytest be_focus_server_tests/integration be_focus_server_tests/load be_focus_server_tests/data_quality be_focus_server_tests/conftest.py `
              -m "smoke" `
              --env staging `
              -v `
              --maxfail=10 `
              --junitxml=$xmlFile `
              --cov=be_focus_server_tests `
              --cov-report=term-missing `
              --tb=short 2>&1 | Tee-Object -Variable pytestOutput
            
            $exitCode = $LASTEXITCODE
            Write-Host "Pytest exit code: $exitCode"
          } catch {
            Write-Host "::error::Pytest execution failed: $_"
            $exitCode = 1
          } finally {
            # Always ensure XML file exists (create empty one if pytest failed before creating it)
            if (-not (Test-Path $xmlFile)) {
              Write-Host "::warning::No XML file created - creating empty one to indicate failure"
              $emptyXml = '<?xml version="1.0" encoding="UTF-8"?><testsuite name="smoke" tests="0" failures="0" errors="1" skipped="0" time="0"><testcase name="pytest_execution_failed" classname="pytest"><error message="Pytest failed before tests could run (possibly health check or collection error)" type="ExecutionError">Pytest failed before tests could run</error></testcase></testsuite>'
              $emptyXml | Out-File -FilePath $xmlFile -Encoding utf8 -Force
              Write-Host "Created empty XML file: $xmlFile"
            } else {
              Write-Host "XML file exists: $xmlFile"
            }
            
            # Store exit code for failure detection (works even with continue-on-error)
            echo "EXIT_CODE=$exitCode" | Out-File -FilePath "test-results/smoke-tests-exit-code.txt" -Encoding utf8 -Force
          }
          
          exit $exitCode

      - name: List test result files
        shell: powershell
        if: always()
        run: |
          Write-Host "Checking for test result files:"
          if (Test-Path test-results\*.xml) {
            Write-Host "Files found!"
            Get-ChildItem test-results\*.xml | ForEach-Object { Write-Host "Found: $($_.FullName)" }
          } else {
            Write-Host "No XML files found in test-results"
          }

      - name: Publish Test Results
        id: test-reporter
        uses: dorny/test-reporter@v1
        if: always()
        continue-on-error: true  # Don't fail workflow here - we'll check failures in a separate step
        with:
          name: Pytest Results - Smoke Tests
          path: test-results/junit-*.xml
          path-replace-backslashes: true
          reporter: java-junit
          list-suites: all
          list-tests: all
          max-annotations: 50
          fail-on-error: false  # Changed to false - we'll fail the workflow explicitly in the failure check step
          only-summary: false
          fail-on-empty: false
          working-directory: ${{ github.workspace }}

      - name: Get Check Run ID
        id: get-check-run
        if: always()
        shell: powershell
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          Write-Host "Getting check run ID for 'Pytest Results - Smoke Tests'..."
          $checkRunId = py -c "import requests, json, os, time; repo = os.environ['GITHUB_REPOSITORY']; sha = os.environ.get('GITHUB_SHA', ''); token = os.environ['GITHUB_TOKEN']; headers = {'Authorization': f'Bearer {token}', 'Accept': 'application/vnd.github.v3+json'}; time.sleep(3); url = f'https://api.github.com/repos/{repo}/commits/{sha}/check-runs'; params = {'check_name': 'Pytest Results - Smoke Tests', 'filter': 'latest'}; r = requests.get(url, headers=headers, params=params); data = r.json(); check_runs = data.get('check_runs', []); check_run_id = str(check_runs[0].get('id', '')) if check_runs else ''; print(check_run_id)" 2>&1
          if ($LASTEXITCODE -eq 0 -and $checkRunId) {
            Write-Host "CHECK_RUN_ID=$checkRunId"
            echo "id=$checkRunId" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          } else {
            Write-Host "CHECK_RUN_ID="
            echo "id=" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          }

      - name: Generate Comprehensive Test Report
        if: always()
        continue-on-error: true  # Don't fail workflow if report generation fails - we still want to check for test failures
        shell: powershell
        env:
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SHA: ${{ github.sha }}
          CHECK_RUN_ID: ${{ steps.get-check-run.outputs.id }}
          ENVIRONMENT: ${{ secrets.ENVIRONMENT || 'staging' }}
          FOCUS_SERVER_HOST: ${{ secrets.FOCUS_SERVER_HOST || '10.10.10.100' }}
        run: |
          $xmlFile = "test-results/junit-smoke.xml"
          if (Test-Path $xmlFile) {
            Write-Host "Generating comprehensive test report..."
            $target = "https://$env:FOCUS_SERVER_HOST$env:FOCUS_API_PREFIX"
            py scripts/generate_comprehensive_test_report.py $xmlFile `
              --environment $env:ENVIRONMENT `
              --target $target
            
            if ($LASTEXITCODE -ne 0) {
              Write-Host "::warning::Report generation script exited with code $LASTEXITCODE, but continuing..."
            }
          } else {
            Write-Host "::warning::JUnit XML file not found: $xmlFile"
            Write-Host "Skipping report generation"
          }

      - name: Parse and Display Test Results (Legacy)
        if: always()
        shell: powershell
        env:
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SHA: ${{ github.sha }}
          CHECK_RUN_ID: ${{ steps.get-check-run.outputs.id }}
        run: |
          py parse_junit_results.py

      - name: Debug - Show test results XML
        if: always()
        shell: powershell
        run: |
          Write-Host "========================================"
          Write-Host "Debug: Test Results XML File"
          Write-Host "========================================"
          $xmlFile = "test-results/junit-smoke.xml"
          if (Test-Path $xmlFile) {
            Write-Host "XML file exists: $xmlFile"
            Write-Host "File contents:"
            Get-Content $xmlFile
            Write-Host ""
            Write-Host "Step outcome: ${{ steps.run-smoke-tests.outcome }}"
          } else {
            Write-Host "XML file NOT found: $xmlFile"
          }
          Write-Host "========================================"

      - name: Fail workflow if tests failed
        if: always()
        shell: powershell
        env:
          RUN_TESTS_OUTCOME: ${{ steps.run-smoke-tests.outcome }}
        run: |
          Write-Host "========================================"
          Write-Host "Checking for test failures..."
          Write-Host "========================================"
          Write-Host "Step outcome: $env:RUN_TESTS_OUTCOME"
          Write-Host "Note: Step outcome may be 'success' even if tests failed due to continue-on-error"
          
          $hasFailures = $false
          
          # Check exit code from test step (more reliable than step outcome with continue-on-error)
          if (Test-Path "test-results/smoke-tests-exit-code.txt") {
            $exitCodeLine = Get-Content "test-results/smoke-tests-exit-code.txt"
            if ($exitCodeLine -match "EXIT_CODE=(\d+)") {
              $exitCode = [int]$matches[1]
              Write-Host "Pytest exit code: $exitCode"
              if ($exitCode -ne 0) {
                Write-Host "::error::Smoke tests exited with code $exitCode"
                $hasFailures = $true
              }
            }
          } else {
            Write-Host "::warning::Exit code file not found - step may not have executed pytest"
          }
          
          # Also check XML file for failures/errors
          $xmlFile = "test-results/junit-smoke.xml"
          if (Test-Path $xmlFile) {
            Write-Host "Checking XML file: $xmlFile"
            try {
              $xml = [xml](Get-Content $xmlFile)
              $testsuite = if ($xml.testsuites) { $xml.testsuites.testsuite } else { $xml.testsuite }
              
              if ($testsuite) {
                $failures = [int]$testsuite.failures
                $errors = [int]$testsuite.errors
                $tests = [int]$testsuite.tests
                
                Write-Host "XML Results: $tests tests, $failures failures, $errors errors"
                
                if ($failures -gt 0 -or $errors -gt 0) {
                  Write-Host "::error::Found failures in XML: $failures failures, $errors errors"
                  $hasFailures = $true
                }
                
                # Check for error/failure elements in XML
                $errorCases = $testsuite.SelectNodes('.//error')
                $failureCases = $testsuite.SelectNodes('.//failure')
                
                if ($errorCases.Count -gt 0 -or $failureCases.Count -gt 0) {
                  Write-Host "Found $($errorCases.Count) error cases and $($failureCases.Count) failure cases in XML"
                  $hasFailures = $true
                }
              }
            } catch {
              Write-Host "::warning::Could not parse XML file: $_"
            }
          } else {
            Write-Host "::warning::XML file not found: $xmlFile"
            # If exit code indicates failure and no XML, that's a failure
            if ($hasFailures) {
              Write-Host "::error::Tests failed but no XML file was generated"
            }
          }
          
          # Run the Python script for additional checks
          Write-Host "Running check_test_failures.py..."
          py check_test_failures.py
          $scriptExitCode = $LASTEXITCODE
          
          if ($scriptExitCode -ne 0) {
            Write-Host "::error::check_test_failures.py detected failures"
            $hasFailures = $true
          }
          
          Write-Host "========================================"
          if ($hasFailures) {
            Write-Host "::error::Test failures detected - failing workflow"
            exit 1
          } else {
            Write-Host "✅ All smoke tests passed"
          }

      - uses: actions/upload-artifact@v4
        if: always()
        with:
          name: smoke-test-reports
          path: test-results\*.xml
          if-no-files-found: warn


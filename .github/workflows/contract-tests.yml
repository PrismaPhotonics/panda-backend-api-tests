name: Contract Tests

on:
  push:
    branches: [ main, develop, "**/feature/**", "**/chore/**" ]
  pull_request:
  workflow_dispatch:
    inputs:
      require_server:
        description: "Fail if Focus server is unreachable"
        default: "true"
        type: choice
        options: [ "true", "false" ]

env:
  PYTHON_VERSION: '3.11'

jobs:
  contract:
    # IMPORTANT: Use self-hosted Linux runner for staging environment access
    # Cloud runners (ubuntu-latest) cannot access internal network (10.10.10.100)
    # If no self-hosted runner available, workflow will fail with clear error message
    runs-on: [self-hosted, Linux]
    timeout-minutes: 30

    env:
      FOCUS_SERVER_HOST: ${{ secrets.FOCUS_SERVER_HOST || '10.10.10.100' }}
      FOCUS_SERVER_PORT: ${{ secrets.FOCUS_SERVER_PORT || '' }}
      FOCUS_API_PREFIX: ${{ secrets.FOCUS_API_PREFIX || '/focus-server' }}
      VERIFY_SSL: ${{ secrets.VERIFY_SSL || 'false' }}
      REQUIRE_SERVER: ${{ inputs.require_server || secrets.REQUIRE_SERVER || 'true' }}
      PYTHONDONTWRITEBYTECODE: 1
      PYTHONUNBUFFERED: 1

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install -U pip setuptools wheel
          
          echo "Installing dependencies (skipping requirements.txt due to resolution-too-deep)..."
          
          # Install core testing framework (pytest 9.0.1 first)
          pip install --no-cache-dir --prefer-binary \
            pytest==9.0.1 pytest-asyncio pytest-timeout pytest-mock pytest-html pytest-cov pytest-json-report pytest-xdist
          
          # Install HTTP and data processing
          pip install --no-cache-dir --prefer-binary \
            requests httpx beautifulsoup4 pydantic pydantic-settings orjson pyyaml
          
          # Install infrastructure packages
          pip install --no-cache-dir --prefer-binary \
            kubernetes pymongo paramiko pika structlog colorlog python-dateutil pytz psutil python-dotenv netaddr
          
          # Install optional packages (skip pytest-xray as it conflicts with pytest 9.0.1)
          pip install --no-cache-dir --prefer-binary \
            allure-pytest jinja2 asyncio-mqtt aiofiles || true
          
          echo "Dependency installation completed!"
          echo "Installed packages:"
          pip list | head -40

      - name: Preflight ג€“ check Focus availability
        id: preflight
        shell: bash
        continue-on-error: true
        run: |
          # Initialize outputs with defaults
          echo "reachable=false" >> $GITHUB_OUTPUT
          echo "status=000" >> $GITHUB_OUTPUT
          
          # Build base URL - don't add port explicitly (HTTPS uses 443 by default)
          # Explicit :443 in URL can cause connection issues
          BASE="https://${FOCUS_SERVER_HOST}${FOCUS_API_PREFIX}"
          echo "Checking $BASE/channels"
          echo "FOCUS_SERVER_HOST: ${FOCUS_SERVER_HOST}"
          echo "FOCUS_SERVER_PORT: ${FOCUS_SERVER_PORT:-'(not used - HTTPS default)'}"
          echo "REQUIRE_SERVER: ${REQUIRE_SERVER}"
          echo ""
          echo "Network diagnostics:"
          echo "  Hostname: $(hostname)"
          echo "  User: $(whoami)"
          echo "  IP: $(hostname -I 2>/dev/null || echo 'unknown')"
          echo ""
          echo "Testing connectivity:"
          
          # Test basic connectivity first
          if ping -c 1 -W 2 "${FOCUS_SERVER_HOST}" > /dev/null 2>&1; then
            echo "  ג… Ping to ${FOCUS_SERVER_HOST} successful"
          else
            echo "  ג ן¸ Ping to ${FOCUS_SERVER_HOST} failed (may be blocked by firewall)"
          fi
          
          # Test port 443
          if timeout 3 bash -c "echo > /dev/tcp/${FOCUS_SERVER_HOST}/443" 2>/dev/null; then
            echo "  ג… Port 443 on ${FOCUS_SERVER_HOST} is reachable"
          else
            echo "  ג ן¸ Port 443 on ${FOCUS_SERVER_HOST} is not reachable"
          fi
          
          echo ""
          echo "Testing HTTP connection:"
          echo "  URL: $BASE/channels"
          set +e
          
          # Try curl with increased timeout and better error handling
          echo "  Running: curl -sk --max-time 30 \"$BASE/channels\""
          
          # Save full output for debugging
          curl_full_output=$(curl -sk -w "\nHTTP_CODE:%{http_code}\nTIME:%{time_total}\n" --max-time 30 "$BASE/channels" 2>&1)
          curl_exit=$?
          
          # Extract HTTP code
          code=$(echo "$curl_full_output" | grep "HTTP_CODE:" | cut -d: -f2 || echo "000")
          
          if [[ $curl_exit -eq 0 && "$code" =~ ^[0-9]+$ && "$code" -ge 200 && "$code" -lt 400 ]]; then
            echo "  ג… Curl command succeeded with HTTP $code"
            response_body=$(echo "$curl_full_output" | grep -v "HTTP_CODE:" | grep -v "TIME:" | head -1)
            echo "  Response: ${response_body:0:100}"
          else
            echo "  ג Curl command failed"
            echo "  Exit code: $curl_exit"
            echo "  Status code: $code"
            echo ""
            echo "  Full curl output (first 50 lines):"
            echo "$curl_full_output" | head -50
            
            # Try with verbose for more details
            echo ""
            echo "  Verbose curl attempt:"
            curl -sk -v --max-time 30 "$BASE/channels" 2>&1 | head -40 || true
            
            # If code is not a valid HTTP status, set to 000
            if [[ ! "$code" =~ ^[0-9]+$ ]]; then
              code="000"
            fi
          fi
          
          echo ""
          echo "Final HTTP status code: $code"
          echo "status=$code" >> $GITHUB_OUTPUT
          
          if [[ "$code" -ge 200 && "$code" -lt 400 ]]; then
            echo "reachable=true" >> $GITHUB_OUTPUT
            echo "ג… Focus server is reachable"
          else
            echo "reachable=false" >> $GITHUB_OUTPUT
            echo "ג ן¸ Focus server unreachable (HTTP $code)"
            echo ""
            echo "Troubleshooting:"
            echo "  1. Check if runner can access ${FOCUS_SERVER_HOST}"
            echo "  2. Check firewall rules"
            echo "  3. Verify network connectivity"
            if [[ "${REQUIRE_SERVER}" == "true" ]]; then
              echo "::error::Focus server unreachable (HTTP $code). Server must be accessible for contract tests."
              echo "::error::Runner is on: $(hostname), trying to reach: ${FOCUS_SERVER_HOST}"
              # Don't exit here - let the workflow continue to generate proper error reports
            fi
          fi

      - name: Debug curl (unreachable)
        if: steps.preflight.outcome == 'success' && steps.preflight.outputs.reachable != 'true'
        shell: bash
        continue-on-error: true
        run: |
          # Use URL without explicit port (HTTPS uses 443 by default)
          BASE="https://${FOCUS_SERVER_HOST}${FOCUS_API_PREFIX}"
          echo "Diagnostic curl -vk $BASE/channels"
          curl -vk --max-time 10 "$BASE/channels" || true
          
          # Also try with explicit port if specified (for debugging)
          if [[ -n "${FOCUS_SERVER_PORT}" && "${FOCUS_SERVER_PORT}" != "443" ]]; then
            echo ""
            echo "Trying with explicit port ${FOCUS_SERVER_PORT}:"
            BASE_WITH_PORT="https://${FOCUS_SERVER_HOST}:${FOCUS_SERVER_PORT}${FOCUS_API_PREFIX}"
            curl -vk --max-time 10 "$BASE_WITH_PORT/channels" || true
          fi

      - name: Run contract tests
        shell: bash
        run: |
          # Build base URL for display (without explicit port)
          FOCUS_URL="$FOCUS_SERVER_HOST$FOCUS_API_PREFIX"
          echo "FOCUS: https://$FOCUS_URL  VERIFY_SSL=$VERIFY_SSL"
          
          # Get reachable status with safe fallback
          # Get reachable status (use GitHub Actions output syntax)
          # Get reachable status (use GitHub Actions output syntax)
          REACHABLE="${{ steps.preflight.outputs.reachable }}"
          # Default to false if empty
          if [[ -z "${REACHABLE}" ]]; then
            REACHABLE="false"
          fi
          echo "Server reachable: ${REACHABLE}"
          echo "Require server: ${REQUIRE_SERVER}"
          mkdir -p reports
          
          # Fail if server is unreachable and REQUIRE_SERVER=true
          if [[ "${REACHABLE}" != "true" && "${REQUIRE_SERVER}" == "true" ]]; then
            echo "::error::Server unreachable and REQUIRE_SERVER=true - cannot run contract tests"
            echo '<?xml version="1.0" encoding="UTF-8"?><testsuite name="contract" tests="0" failures="0" errors="1" skipped="0" time="0"><testcase name="server_unreachable" classname="preflight"><error message="Server unreachable and REQUIRE_SERVER=true" type="ConnectionError">Server unreachable and REQUIRE_SERVER=true</error></testcase></testsuite>' > reports/junit-contract.xml
            exit 1
          fi
          
          # Skip tests if server unreachable and REQUIRE_SERVER=false
          if [[ "${REACHABLE}" != "true" ]]; then
            echo "ג ן¸ Server unreachable - skipping contract tests"
            echo '<?xml version="1.0" encoding="UTF-8"?><testsuite name="contract" tests="0" failures="0" errors="0" skipped="1" time="0"><testcase name="server_unreachable" classname="preflight"><skipped message="Server unreachable"/></testcase></testsuite>' > reports/junit-contract.xml
            exit 0
          fi
          
          # Run tests
          pytest -v focus_server_api_load_tests/focus_api_tests/test_api_contract.py \
            --junitxml=reports/junit-contract.xml \
            --html=reports/contract-report.html \
            --self-contained-html \
            --json-report \
            --json-report-file=reports/contract-report.json \
            --maxfail=10

      - name: Generate console summary
        if: always()
        shell: bash
        run: |
          echo ""
          echo "========================================"
          echo "TEST EXECUTION SUMMARY"
          echo "========================================"
          if [ -f "reports/junit-contract.xml" ]; then
            python3 -c "
          import xml.etree.ElementTree as ET
          import sys
          try:
              tree = ET.parse('reports/junit-contract.xml')
              root = tree.getroot()
              if root.tag == 'testsuites':
                  suites = root.findall('.//testsuite')
                  total = sum(int(s.get('tests', 0)) for s in suites)
                  failures = sum(int(s.get('failures', 0)) for s in suites)
                  errors = sum(int(s.get('errors', 0)) for s in suites)
                  skipped = sum(int(s.get('skipped', 0)) for s in suites)
                  time = sum(float(s.get('time', 0)) for s in suites)
              elif root.tag == 'testsuite':
                  total = int(root.get('tests', 0))
                  failures = int(root.get('failures', 0))
                  errors = int(root.get('errors', 0))
                  skipped = int(root.get('skipped', 0))
                  time = float(root.get('time', 0))
              else:
                  # Unknown root tag, try to count testcases
                  testcases = root.findall('.//testcase')
                  total = len(testcases)
                  failures = len(root.findall('.//failure'))
                  errors = len(root.findall('.//error'))
                  skipped = len(root.findall('.//skipped'))
                  time = 0.0
              passed = total - failures - errors - skipped
              print(f'Total Tests: {total}')
              print(f'Passed: {passed}')
              print(f'Failed: {failures}')
              print(f'Errors: {errors}')
              print(f'Duration: {time:.2f}s')
          except Exception as e:
              print(f'Error parsing XML: {e}')
              sys.exit(0)
          "
            echo "========================================"
            echo ""
          else
            echo "No test results found"
            echo "========================================"
            echo ""
          fi

      - name: Upload test reports
        if: always()
        id: upload-artifact
        uses: actions/upload-artifact@v4
        with:
          name: contract-test-reports
          path: |
            reports/junit-*.xml
            reports/*.html
            reports/*.json
          retention-days: 30
          if-no-files-found: warn

      - name: Get artifact download URL
        if: always() && steps.upload-artifact.outcome == 'success'
        id: get-artifact-url
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python3 << 'SCRIPT'
          import os
          import time
          import json
          import urllib.request
          import urllib.error
          
          repo = os.environ.get("GITHUB_REPOSITORY", "")
          runId = os.environ.get("GITHUB_RUN_ID", "")
          token = os.environ.get("GITHUB_TOKEN", "")
          artifactName = "contract-test-reports"
          outputFile = os.environ.get("GITHUB_OUTPUT", "")
          
          if not repo or not runId or not token:
              print("Missing required environment variables")
              exit(0)
          
          artifactsUrl = f"https://api.github.com/repos/{repo}/actions/runs/{runId}/artifacts"
          headers = {
              "Authorization": f"Bearer {token}",
              "Accept": "application/vnd.github.v3+json"
          }
          
          maxRetries = 5
          retryDelay = 2
          artifactId = None
          
          for i in range(1, maxRetries + 1):
              try:
                  print(f"Attempt {i} of {maxRetries} to get artifact ID...")
                  req = urllib.request.Request(artifactsUrl, headers=headers)
                  with urllib.request.urlopen(req, timeout=10) as response:
                      data = json.loads(response.read())
                      
                      artifacts = data.get("artifacts", [])
                      print(f"Found {len(artifacts)} artifacts")
                      for artifact in artifacts:
                          print(f"  - {artifact.get('name')} (ID: {artifact.get('id')})")
                      
                      artifact = next((a for a in artifacts if a.get("name") == artifactName), None)
                      
                      if artifact:
                          artifactId = artifact.get("id")
                          serverUrl = os.environ.get("GITHUB_SERVER_URL", "https://github.com")
                          downloadUrl = f"{serverUrl}/{repo}/actions/runs/{runId}/artifacts/{artifactId}"
                          
                          if outputFile:
                              with open(outputFile, "a", encoding="utf-8") as f:
                                  f.write(f"url={downloadUrl}\n")
                          
                          print(f"Found artifact ID: {artifactId}")
                          print(f"Download URL: {downloadUrl}")
                          break
                      else:
                          print(f"Artifact '{artifactName}' not found in response")
                          if i < maxRetries:
                              print(f"Waiting {retryDelay} seconds before retry...")
                              time.sleep(retryDelay)
              except urllib.error.HTTPError as e:
                  print(f"HTTP Error on attempt {i}: {e.code} - {e.reason}")
                  if i < maxRetries:
                      time.sleep(retryDelay)
              except Exception as e:
                  print(f"Error on attempt {i}: {e}")
                  if i < maxRetries:
                      time.sleep(retryDelay)
          
          if not artifactId:
              print(f"ERROR: Could not get artifact ID after {maxRetries} attempts")
          SCRIPT

      - name: Generate GitHub Actions summary
        if: always()
        shell: bash
        env:
          ARTIFACT_DOWNLOAD_URL: ${{ steps.get-artifact-url.outputs.url }}
        run: |
          summaryPath="$GITHUB_STEP_SUMMARY"
          if [ -z "$summaryPath" ]; then
            echo "GITHUB_STEP_SUMMARY not set, skipping summary generation"
            exit 0
          fi
          
          python3 << 'SCRIPT'
          import xml.etree.ElementTree as ET
          import os
          import sys
          
          summaryPath = os.environ.get("GITHUB_STEP_SUMMARY", "")
          artifactUrl = os.environ.get("ARTIFACT_DOWNLOAD_URL", "")
          
          if not summaryPath:
              print("GITHUB_STEP_SUMMARY not set")
              sys.exit(0)
          
          if os.path.exists("reports/junit-contract.xml"):
              try:
                  tree = ET.parse("reports/junit-contract.xml")
                  root = tree.getroot()
                  
                  # Handle both testsuites and testsuite
                  if root.tag == "testsuites":
                      suites = root.findall(".//testsuite")
                      total = sum(int(s.get("tests", 0)) for s in suites)
                      failures = sum(int(s.get("failures", 0)) for s in suites)
                      errors = sum(int(s.get("errors", 0)) for s in suites)
                      skipped = sum(int(s.get("skipped", 0)) for s in suites)
                      time = sum(float(s.get("time", 0)) for s in suites)
                  elif root.tag == "testsuite":
                      total = int(root.get("tests", 0))
                      failures = int(root.get("failures", 0))
                      errors = int(root.get("errors", 0))
                      skipped = int(root.get("skipped", 0))
                      time = float(root.get("time", 0))
                  else:
                      # Unknown root tag, try to count testcases
                      testcases = root.findall(".//testcase")
                      total = len(testcases)
                      failures = len(root.findall(".//failure"))
                      errors = len(root.findall(".//error"))
                      skipped = len(root.findall(".//skipped"))
                      time = 0.0
                  
                  passed = total - failures - errors - skipped
                  timeRounded = round(time, 2)
                  status = "[OK]" if failures == 0 and errors == 0 else "[FAIL]"
                  
                  with open(summaryPath, "w", encoding="utf-8") as f:
                      f.write(f"## Contract Tests Results {status}\n\n")
                      f.write("| Metric | Value |\n")
                      f.write("|--------|-------|\n")
                      f.write(f"| **Total Tests** | {total} |\n")
                      f.write(f"| **Passed** | {passed} |\n")
                      f.write(f"| **Failed** | {failures} |\n")
                      f.write(f"| **Errors** | {errors} |\n")
                      f.write(f"| **Skipped** | {skipped} |\n")
                      f.write(f"| **Duration** | {timeRounded}s |\n\n")
                      f.write("### Test Reports\n\n")
                      
                      if artifactUrl:
                          f.write(f"- [Download All Reports]({artifactUrl}) - Download ZIP with HTML, JSON, and JUnit XML reports\n\n")
                      else:
                          repo = os.environ.get("GITHUB_REPOSITORY", "")
                          runId = os.environ.get("GITHUB_RUN_ID", "")
                          serverUrl = os.environ.get("GITHUB_SERVER_URL", "")
                          if repo and runId and serverUrl:
                              runUrl = f"{serverUrl}/{repo}/actions/runs/{runId}"
                              f.write(f"- [Download Reports]({runUrl}) - Go to workflow run page and download \`contract-test-reports\` artifact\n\n")
                          else:
                              f.write("- Download Reports - Check artifacts section in workflow run\n\n")
                      
                      if failures > 0 or errors > 0:
                          f.write("### Failed Tests\n\n")
                          failedTests = root.findall(".//testcase[failure or error]")
                          count = 0
                          for test in failedTests[:10]:
                              name = test.get("name", "unknown")
                              classname = test.get("classname", "unknown")
                              failure = test.find("failure")
                              error = test.find("error")
                              msg = ""
                              if failure is not None:
                                  msg = failure.get("message", "") or (failure.text or "")[:200]
                              elif error is not None:
                                  msg = error.get("message", "") or (error.text or "")[:200]
                              msg = msg.replace("`", "'")[:200]
                              f.write(f"- **{classname}::{name}**\n")
                              f.write(f"  ```{msg}```\n\n")
                              count += 1
                          if len(failedTests) > 10:
                              f.write(f"*... and {len(failedTests) - 10} more failures*\n\n")
                  
                  print("[OK] GitHub Actions summary generated")
              except Exception as e:
                  with open(summaryPath, "w", encoding="utf-8") as f:
                      f.write(f"## Error parsing test results\n\nError: {e}\n")
                  print(f"Error: {e}")
          else:
              with open(summaryPath, "w", encoding="utf-8") as f:
                  f.write("## Warning: No test results found\n\n")
                  f.write("Test execution may have failed before generating reports.\n")
          SCRIPT

